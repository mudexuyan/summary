# 消息队列
## 使用消息队列的原因
1. 作用
   1. 解耦，生产端和消费端不需要相互依赖。
   2. 削峰，打平高峰期的流量，消费端可以以自己的速度处理，同时也无需在高峰期增加太多资源，提高资源利用率。缓存数据库压力
   3. 异步，生产端不需要等待消费端响应，直接返回，提高了响应时间和吞吐量
   4. 提高消费端性能。消费端可以利用buffer等机制，做批量处理，提高效率。
2. 问题
   1. 一致性问题：消费者没有正确消费消息
   2. 系统更复杂
3. MQ
   1. RabbitMq，延迟低，单机吞吐量也低
   2. RocketMq，高吞吐，可靠不会消息丢失，高可用（分布式架构），功能完善，易扩展
   3. Kafka，高吞吐，可靠消息不会丢失，高可用（分布式架构），功能简单，时候大数据的实时计算和日志采集。社区活跃
## 消息队列的高可用
1. kafka
   1. 分布式架构（由多个 broker 组成，每个 broker 是一个节点；你创建一个topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据）
   2. HA（高可用）机制，复制副本机制，每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。
   3. 写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）
   4. 消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。
   5. 某个 broker 宕机了，从foller中重新选举leader

## 保证消息不被重复消费
1. kafka
   1. 每个消息都有offset，consumer消费消息后，会把这个消息的offset定时发给kafka，表示已经消费过。但是，如果在提交offset的时候出错，则会重复消费，此时通过去重需要保证消息的幂等性

## 保证消息的可靠性传输
1. kafka
   1. 消费端丢失数据
      1. kafka默认自动提交offset，consumer提交了offset，但在消费时出错
      2. 关闭自动提交，自己手动提交，可能出现重复消费的情况
   2. kafka丢失数据
      1. 某个broker宕机，但数据未同步完
   3. 生产者不会丢失数据（如果producer设置了acks=all，要求每条数据写入所有 replica 之后，才能认为是写成功了）

## 多线程保证消息的顺序性
1. 本地写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性

## 解决消息队列的延时以及过期失效问题
1. kafka，数据库挂了，不能消费消息队列的消息，消息队列消息越来越多
   1. 先临时扩容
   2. mq中的消息过期了，大量数据丢失：批量重导
   3. mq快满了：提高消费并行度、跳过非重要消息

## 设计mq系统
1. 设计分布式，保证高吞吐
2. 顺序写磁盘，保证数据丢失问题
3. 可用性，leader-foller机制
4. 数据丢失问题

# 搜索引擎ElasticSearch
1. 倒排索引



# 分库分表
## 分表
1. 将一个表的内容放到多个表中，将用户表的每个用户分成一个表

## 分库
1. 将一个库的内容分到多个库中

## 中间件
1. Sharding-jdbc，功能完善，支持读写分离，优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高
2. Mycat，功能完善，支持读写分离，需要部署

水平拆分的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。

垂直拆分的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些

## mysql读写分离
1. 基于主从复制架构，就搞一个主库，挂多个从库，然后只是写主库，然后主库会自动把数据给同步到从库上去
2. 主从同步延时：写入主库时，主库同步到从库，再从从库读取数据。延时问题，会导致业务端先写再查，查不到数据


## 设计高并发系统
1. 系统拆分，拆分成多个子系统，dubbo
2. 缓存，解决读高并发
3. mq，解决写高并发，异步
4. 分库分表，数据库分库分表
5. 读写分离，数据库读写分离
6. elasticSearch

### 分库分表
1. 分库：将一个库的数据分到多个库，
2. 分表：将一个表的数据分成多个表，例如根据用户id分表，每个用户一个表
