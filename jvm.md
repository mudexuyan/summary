# JVM

## 一、自动内存管理
### 1、运行时数据区

备注
- java方法：是由java语言编写，编译成字节码，存储在class文件中的。java方法是与平台无关的。
- 本地（native）方法：本地方法是由其他语言（如C、C++ 或其他汇编语言）编写，编译成和处理器相关的代码。

1. 线程私有
- 程序计数器 
  -  如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，这个计数器值则应为空。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

- 虚拟机栈
  - 虚拟机栈描述的是Java方法执行的线程内存模型： 每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程
  - 局部变量表，以局部变量槽的形式存储了八种基础数据类型、对象引用类型、和returnAddress类型（指向了一条字节码指令的地址）。其中double和long占两个槽，其它占一个。
  -  如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

- 本地方法栈
  - 虚拟机栈为虚拟机执行Java方法（也就是字节码） 服务， 而本地方法栈则是为虚拟机使用到的本地方法服务。
  - StackOverflowError、OutOfMemoryError

2. 线程共享
- Java堆
  - 虚拟机启动时创建，存储对象的实例
  - OutOfMemoryError
- 方法区
  - 存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据
  - jdk8之前永久代的概念更容易导致内存溢出的情况（MaxPermSize），jdk8之后逐渐采用本地内存的元空间实现方法区
  - OutOfMemoryError
    - 运行时常量池
### 2、直接内存
- OutOfMemoryError
- 可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。

### 3、HotSpot虚拟机对象
#### 对象的创建
1. new过程：对象内存分配->内存空间初始化为0（保证未赋值也可以直接使用）-> 必要设置（哪个类的实例、元数据信息、对象哈希码等）-> 执行init方法（程序员自定义的初始化方法）

2. 分配对象空间：垃圾收集器是否有空间压缩整理能力决定了java堆的内存分配方式，有则使用指针碰撞，无则使用空闲列表
- 指针碰撞，堆中的内存空闲部分和非空闲部分通过指针分成两部分，每次生成新对象，则指针前进相等距离。
- 空闲列表，堆中的内存空闲部分和非空闲部分交错在一起，通过列表维护空闲内存

3. 线程安全问题
- 现象：并发情况下，正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。
- 分配内存时同步处理，CAS+失败重试保证原子性
- 每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

#### 对象的内存布局
1. 对象头
- 自身运行时数据：如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳，等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称为“Mark Word”。
- 类型指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例

2. 实例数据，对象存储的有效信息（字段内容），默认分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary
Object Pointers）

3. 对齐填充（非必须），起占位符作用，保证对象起始地址是8字节的整数倍

#### 对象的访问定位 
1. 句柄（指向java堆实例数据的指针+指向方法区类型数据的指针）
- 需划分内存存储对象的句柄地址；对象移动只需改变句柄的实例数据指针
2. 直接指针
- 对象的内存布局需考虑访问对象类型的信息；快

## 二、垃圾收集器和内存分配策略
### 回收内存  
回收Java堆和方法区的内存。程序计数器、jvm栈和本地方法栈随线程开始和结束，内存的分配和回收基本在编译期时就确定了。

### 回收java堆对象
1. 对象死去标志（不再被使用的对象）
- 引用计数法
  - 对对象添加一个计数器，每次被引用时，+1；引用失效时，-1；计数器为0时，表示不再使用
  - 不能解决循环引用问题（A引用B，B引用A）
- 可达性分析算法
  - 以根对象GC Roots集合为起始节点，根据引用关系搜索（路径成为引用链），没有引用链的对象则是不可达对象，表示不再使用
  - GC Roots集合包括：虚拟机栈中引用的对象、方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法JNI引用的对象、synchronized修饰的对象等

2. 引用概念
- 强引用，代码中普遍存在的引用赋值，不会被回收，Object obj = new Object()
- 软引用，描述还有用但非必须的对象，系统发生内存溢出前，对其进行二次回收
- 弱引用，描述非必须的对象，只能存活到下一次垃圾收集
- 虚引用，为了能在这个对象被收集器回收时收到一个系统通知。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
  
3. 对象不可达，对象不一定死亡。可达性分析算法过程：
- 对象判定不可达，第一次标记 -> 判断对象有必要执行finalize()方法
  - 没有必要执行，则直接回收：对象没有覆盖finalize()方法， 或者finalize()方法已经被虚拟机调用过
  - 有必要执行：将对象放入F-Queue中，由jvm自动建立的、低调度优先级的Finalizer线程执行它们的finalize()方法
  - 此时对象可达则不会被回收；否则第二次标记被回收
- 对象只能拯救自己一次，finalize()方法只能被系统调用一次

### 回收方法区
1. 回收的目标
- 废弃的常量，类型回收java堆中的对象
- 不再使用的类型
  - 判断该类所有实例被回收
  - 加载该类的类加载器被回收
  - 该类对应的java.lang.Class对象没有被引用，无法通过反射访问该类的方法
  - 满足上述三个条件的类允许被回收，不一定会被回收

### 垃圾收集算法
1. 追踪式垃圾收集（主要）、引用计数式垃圾收集
2. 分代收集理论
   1. 名词解释：java堆可分为新生代、老年代：在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。
      1. 新生代收集（Minor GC/Young GC） 
      2. 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
      3. 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
      4. 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。
   2. 弱分代，大多数对象都是朝生夕灭的。保留少量存活对象而不是标记大量被回收对象
   3. 强分代，熬过越多次垃圾收集过程的对象就越难以消亡。收集难以消亡的对象到一起，以较低频率回收
   4. 跨代引用：跨代引用相对于同代引用来说仅占极少数
      1. 在新生代建立全局数据结构记忆集，将老年代划分若干块，并标记哪一块内存存在跨代引用。避免了当仅收集新生代时，需要遍历老年代对象对新生代对象的可达引用

3. 标记-清除算法
   1. 先标记，再清除
   2. 执行效率不稳定；内存空间碎片化严重

4. 标记-复制算法
   1. 将分区分成相等两部分，当一部分内存用完了，将存活的对象复制到另一块，再将当前块的内存清理
   2. 简单；空间浪费了一半

5. 标记-整理算法
    1. 标记对象
    2. 让存活对象向内存空间一端移动，清理边界外的内存
    3. 移动对象花费代价

### HostSpot算法细节
1. 根节点枚举，由于对象引用不断变化，必须暂停用户进程
2. 安全点
- jvm通过OopMap找到对象引用位置，而不是检查所有执行上下文和全局引用位置。
- jvm只在特定位置（安全点）生成OopMap
  - 抢先式中断
  - 主动式中断

3. 安全区域
- 安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。
- 用户线程处于sleep状态或blocked状态，线程无法响应虚拟机的中断请求，不能到达安全点中断挂起自己  

4. 记忆集和卡表
- 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。 
- 为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集的数据结构，用以避免把整个老年代加进GC Roots扫描范围。 
- 三种精度实现方案
  - 字长精度，每个记录精确到机器字长，该字含有跨代指针
  - 对象精度，每个记录精确到一个对象，该对象里有字段含有跨代指针。
  - 卡精度，卡表。每个记录精确到一块内存区域，该区域内有对象含有跨代指针。
    - 卡页，节数组CARD_TABLE（卡表最简单形式）的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page） 
    - 当卡页内有一个对象存在跨代指针，则将卡表对于数组元素置为1，表示脏。垃圾回收时，筛选卡表中变脏的元素，将其加入GC Roots扫描。

- 卡表元素维护问题

- 伪共享问题
  - 伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。

5. 写屏障
- 解决卡表元素维护问题

6. 并发可达性分析
- 收集线程和用户线程并发时，可能出现将存活对象标记为死亡
- 解决并发扫描时对象消失问题
  - 产生条件
    - 赋值器插入了一条或多条从黑色对象（扫描结束）到白色对象的新引用
    - 赋值器删除了全部从灰色对象（正在扫描，未扫描完）到该白色对象（未扫描）的直接或间接引用
  - 增量更新，破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
  - 原始快照，破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索


### 经典垃圾收集器
1. Serial收集器，单进程收集器
2. ParNew收集器，多线程并行收集器
3. Parallel Scavenge收集器，新生代收集器，标记-复制
4. Serial Old收集器，Serial收集器老年代版本，基于标记-整理
5. Parallel Old收集器是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现
6. CMS收集器，基于标记-清除，分代收集
   1. 初始标记，标记GC Roots直接关联到的对象；需要暂停其它线程
   2. 并发标记，从GC Roots直接关联到的对象搜索间接关联的对象，可以和垃圾收集线程并发运行
   3. 重新标记，修正并发标记期间，产生变动的标记对象；需要暂停其它线程
   4. 并发清除，清除死亡对象
   5. 缺点
      1. 对处理器资源敏感
      2. 无法处理浮动垃圾（并发标记和并发清理产生的垃圾对象）
      3. 空间碎片
   6. 收集线程与用户线程互不干扰：增量更新算法
   7. jdk9被舍弃
7. Garbage First收集器，整体标记-整理，局部region标记-复制，MixedGC
   1. 基于region内存布局，将java堆划分为多个大小相等的独立区域，每个区域都可以是新生代或老年。G1收集器追踪每个region垃圾的价值大小（价值即回收所获得的空间大小以及回收所需时间的经验值），维护一个优先级列表，优先处理回收价值最大的region。可以指定最大停顿时间。动态确定回收集。  
   2. 跨regin引用问题：通过记忆集避免GC Roots扫描。每个region维护自己的记忆集，记录其它region指向自己的指针  
   3. 收集线程与用户线程互不干扰：原始快照SATB算法。G1收集器为每个region分配两个TAMS指针，将region一部分空间划分处理并发回收时产生的新对象，其地址在两个指针以上，默认是存活的
   4. humongous region：存放大对象，直接进入老年代
   5. 过程
      1. 初始标记，标记GC Roots能直接关联到的对象，并且修改TAMS指针的值
      2. 并发标记，从GC Root开始对堆中对象进行可达性分析，找出要回收的对象，扫描结束后重新处理SATB记录下的在并发时有引用变动的对象
      3. 最终标记，对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
      4. 筛选回收，负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。
8. CMS、G1比较
- 都是要卡表处理跨代指针，G1更加复杂，每个region都需有一份卡表（其它region引用该region）；CMS只需要处理老年代对新生代的引用，新生代建立一份全局的卡表
- 并发对象可达性问题，G1原始快照；CMS增量更新
- 都使用写（后）屏障维护卡表，CMS同步处理写屏障；G1将G1为了实现快照搜索算法还需要写前屏障跟踪并发时指针变化情况。同时把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理。

### 低延迟垃圾收集器，非分代收集
1. 衡量垃圾收集器的指标：内存占用、吞吐量和延迟
2. Shenandoah收集器，与G1的不同
   1. 采用并发的整理标记，G1的筛选回收可以收集线程多线程并发，但不能和用户线程并发
   2. 不使用分代收集
   3. 连接矩阵代替记忆集
   4. 过程如下
      1. 初始标记，同G1
      2. 并发标记，同G1
      3. 最终标记，同G1
      4. 并发清理，清理无存活对象的region
      5. 并发回收（核心区别），将回收集的存活对象复制到未被使用的region。读屏障和brooks pointers转发指针解决复制问题（移动对象同时，用户线程可能需要读写该对象）
      6. 初始引用更新，并发复制对象结束后，建立线程集合点，确保对象移动已完成
      7. 并发引用更新，与用户线程并发，按照内存物料地址顺序，搜索引用类型，更新指向对象的引用地址
      8. 最终引用更新，解决了堆中的引用更新后，还要修正存在于GC Roots中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关
      9. 并发清理，回收region内存空间
    5. 转发指针
       1. 在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己
       2. 通过CAS保证并发时对象的正确访问（存在进程竞争）
    6. 读屏障，类似写屏障
       1. 所谓“引用访问屏障”是指内存屏障只拦截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写，这能够省去大量对原生类型、对象比较、对象加锁等场景中设置内存屏障所带来的消耗。

3. ZGC收集器，
   1. region类型
      1. 小型，2MB
      2. 中型，32MB
      3. 大型，动态变化，2MB整数倍
   2. 核心，并发整理算法
      1. 读屏障
      2. 染色指针，将少量额外信息存储在指针上


## 三、虚拟机执行子系统
### 类文件结构
1. java程序经过javac编译器，变成字节码(.class文件)，运行在java虚拟机上
2. CLass类文件的结构
- 任何一个Class文件都对应着唯一的一个类或接口的定义信息。Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符。
   1. 魔数，每个class文件的头四个字节，作用是确定这个文件是否为一个能被虚拟机接受的Class文件。
   2. Class文件版本号，紧接着魔数后的四个字节。第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。
   3. 常量池入口，常量池存放字面量和符号引用
   4. 访问标志，2个字节。用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型； 是否定义为abstract类型；如果是类的话，是否被声明为final等等。
   5. 类索引、父类索引与接口索引集合。Class文件中由这三项数据来确定该类型的继承关系。类索引用于确定这个类的全限定名， 父类索引用于确定这个类的父类的全限定名。 
   6. 字段表集合，用于描述接口或者类中声明的变量。访问标志、名称索引、描述符索引、属性表集合。
      1. 包括类级变量以及实例级变量， 但不包括在方法内部声明的局部变量。
      2. 字段的作用域（public、private、protected修饰符 、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。 
   7. 方法表集合，用于描述接口或者类中声明的方法。访问标志（区别）、名称索引、描述符索引、属性表集合（区别）
      1. volatile关键字和transient关键字不能修饰方法
      2. synchronized、native、strictfp和abstract关键字可以修饰方法
   8. 属性表集合
      1. code属性，Java程序方法体里面的代码经过Javac编译器处理之后， 最终变为字节码指令存储在Code属性内。
      2. 。。。
3. 字节码指令
   1. Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。
   2. 基本流程如下
   ```
   do {
      自动计算PC寄存器的值加1;
      根据PC寄存器指示的位置， 从字节码流中取出操作码;
      if (字节码存在操作数) 从字节码流中取出操作数;
      执行操作码所定义的操作;
    } while (字节码流长度 > 0);
  
   ```
   3. 字节码与数据类型
      1. 加载、存储
      2. 运算
      3. 类型转换
      4. 对象创建和访问
      5. 控制转移
      6. 方法调用
      7. 异常处理
      8. 同步
      9. 操作数栈

    4. 公有设计，私有实现

### 虚拟机加载机制
#### 类加载的时机
1. Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。 
![类的生命周期](图片/类的生命周期.png)
2. 其中加载、验证、准备、初始化、卸载五个顺序是确定的。
3. 解析阶段不一定，为了支持动态绑定，可能会初始化阶段再开始
4. 类主动初始化的六种情况
   1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：
      1. 使用new关键字实例化对象的时候。
      2. 读取或设置一个类型的静态字段（被final修饰、 已在编译期把结果放入常量池的静态字段除外）的时候。
      3. 调用一个类型的静态方法的时候。
   2. 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
   3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
   4. 当虚拟机启动时，用户需要指定一个要执行的主类（ 包含main()方法的那个类），虚拟机会先初始化这个主类。
   5. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、 REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
   6. 当一个接口中定义了JDK 8新加入的默认方法（ 被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
5. 接口主动初始化，与类主动初始化大部分相同
- 区别在第三种：一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。
#### 类加载的过程
1. 加载
   1. 通过一个类的全限定名来获取定义此类的二进制字节流
   2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
   3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口
2. 验证，确保class文件的字节流中包含的信息符合约束要求
   1. 文件格式验证，验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理
   2. 元数据验证（数据类型），对类的元数据信息进行语义校验
   3. 字节码验证（类的方法体），通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。
   4. 符合引用验证，在解析时发生。对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验
3. 准备，为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。
   1. 这个阶段只为类变量分配内存，实例变量需要初始化时分配内存
   2. 如果类变量未被final修饰，初始化为0值；否则初始化设定的值
4. 解析，Java虚拟机将常量池内的符号引用替换为直接引用的过程
   1. 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。
   2. 直接引用：是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。
5. 初始化
   1. 根据代码初始化类变量和其它资源，初始化阶段就是执行类构造器<clinit>()方法的过程。
   2. <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，静态语句块可以赋值，不能访问
#### 类加载器，实现类加载的一段代码
1. 让应用程序自己决定如何获取所需的类，然后“通过一个类的全限定名来获取描述该类的二进制字节流（加载的第一阶段）”
2. 类加载器+类本身共同确立类在jvm中的唯一性
   1. 判断两个类相等(equal()、isINstance()的结果)，需要判断加载类的加载器是否相同
3. 双亲委派模型
   1. 三层类加载器
      1. 启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分。负责加载存放在<JAVA_HOME>\lib目录。
      2. 其它的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。
         1. 扩展类加载器，负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库
         2. 应用类加载器，加载用户类路径（ClassPath）上所有的类库
   2. 双亲委派模型
   ![双亲委派](图片/双亲委派.png)
   3. 双亲委派模型过程
      1. 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是先判断是否加载过这个类，未加载过则把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。
      2. 好处：无论哪一个类加载器要加载一个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此这个类在程序的各种类加载器环境中都能够保证是同一个类。
   4. 模块化系统
      1. 



### 虚拟机字节码执行引擎