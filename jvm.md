# JVM

## 一、自动内存管理
### 1、运行时数据区

备注
- java方法：是由java语言编写，编译成字节码，存储在class文件中的。java方法是与平台无关的。
- 本地（native）方法：本地方法是由其他语言（如C、C++ 或其他汇编语言）编写，编译成和处理器相关的代码。

1. 线程私有
- 程序计数器 
  -  如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，这个计数器值则应为空。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

- 虚拟机栈
  - 虚拟机栈描述的是Java方法执行的线程内存模型： 每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程
  - 局部变量表，以局部变量槽的形式存储了八种基础数据类型、对象引用类型、和returnAddress类型（指向了一条字节码指令的地址）。其中double和long占两个槽，其它占一个。
  -  如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

- 本地方法栈
  - 虚拟机栈为虚拟机执行Java方法（也就是字节码） 服务， 而本地方法栈则是为虚拟机使用到的本地方法服务。
  - StackOverflowError、OutOfMemoryError

2. 线程共享
- Java堆
  - 虚拟机启动时创建，存储对象的实例
  - OutOfMemoryError
- 方法区
  - 存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据
  - jdk8之前永久代的概念更容易导致内存溢出的情况（MaxPermSize），jdk8之后逐渐采用本地内存的元空间实现方法区
  - OutOfMemoryError
    - 运行时常量池
### 2、直接内存
- OutOfMemoryError
- 可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。

### 3、HotSpot虚拟机对象
#### 对象的创建
1. new过程：对象内存分配->内存空间初始化为0（保证未赋值也可以直接使用）-> 必要设置（哪个类的实例、元数据信息、对象哈希码等）-> 执行init方法（程序员自定义的初始化方法）

2. 分配对象空间：垃圾收集器是否有空间压缩整理能力决定了java堆的内存分配方式，有则使用指针碰撞，无则使用空闲列表
- 指针碰撞，堆中的内存空闲部分和非空闲部分通过指针分成两部分，每次生成新对象，则指针前进相等距离。
- 空闲列表，堆中的内存空闲部分和非空闲部分交错在一起，通过列表维护空闲内存

3. 线程安全问题
- 现象：并发情况下，正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。
- 分配内存时同步处理，CAS+失败重试保证原子性
- 每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

#### 对象的内存布局
1. 对象头
- 自身运行时数据：如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳，等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称为“Mark Word”。
- 类型指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例

2. 实例数据，对象存储的有效信息（字段内容），默认分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary
Object Pointers）

3. 对齐填充（非必须），起占位符作用，保证对象起始地址是8字节的整数倍

#### 对象的访问定位 
1. 句柄（指向java堆实例数据的指针+指向方法区类型数据的指针）
- 需划分内存存储对象的句柄地址；对象移动只需改变句柄的实例数据指针
2. 直接指针
- 对象的内存布局需考虑访问对象类型的信息；快

## 二、垃圾收集器和内存分配策略
### 回收内存  
回收Java堆和方法区的内存。程序计数器、jvm栈和本地方法栈随线程开始和结束，内存的分配和回收基本在编译期时就确定了。

### 回收java堆对象
1. 对象死去标志（不再被使用的对象）
- 引用计数法
  - 对对象添加一个计数器，每次被引用时，+1；引用失效时，-1；计数器为0时，表示不再使用
  - 不能解决循环引用问题（A引用B，B引用A）
- 可达性分析算法
  - 以根对象GC Roots集合为起始节点，根据引用关系搜索（路径成为引用链），没有引用链的对象则是不可达对象，表示不再使用
  - GC Roots集合包括：虚拟机栈中引用的对象、方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法JNI引用的对象、synchronized修饰的对象等

2. 引用概念
- 强引用，代码中普遍存在的引用赋值，不会被回收，Object obj = new Object()
- 软引用，描述还有用但非必须的对象，系统发生内存溢出前，对其进行二次回收
- 弱引用，描述非必须的对象，只能存活到下一次垃圾收集
- 虚引用，为了能在这个对象被收集器回收时收到一个系统通知。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
  
3. 对象不可达，对象不一定死亡。可达性分析算法过程：
- 对象判定不可达，第一次标记 -> 判断对象有必要执行finalize()方法
  - 没有必要执行，则直接回收：对象没有覆盖finalize()方法， 或者finalize()方法已经被虚拟机调用过
  - 有必要执行：将对象放入F-Queue中，由jvm自动建立的、低调度优先级的Finalizer线程执行它们的finalize()方法
  - 此时对象可达则不会被回收；否则第二次标记被回收
- 对象只能拯救自己一次，finalize()方法只能被系统调用一次

### 回收方法区
1. 回收的目标
- 废弃的常量，类型回收java堆中的对象
- 不再使用的类型
  - 判断该类所有实例被回收
  - 加载该类的类加载器被回收
  - 该类对应的java.lang.Class对象没有被引用，无法通过反射访问该类的方法
  - 满足上述三个条件的类允许被回收，不一定会被回收

### 垃圾收集算法
1. 追踪式垃圾收集（主要）、引用计数式垃圾收集
2. 分代收集理论
   1. 名词解释：java堆可分为新生代、老年代：在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。
      1. 新生代收集（Minor GC/Young GC） 
      2. 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
      3. 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
      4. 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。
   2. 弱分代，大多数对象都是朝生夕灭的。保留少量存活对象而不是标记大量被回收对象
   3. 强分代，熬过越多次垃圾收集过程的对象就越难以消亡。收集难以消亡的对象到一起，以较低频率回收
   4. 跨代引用：跨代引用相对于同代引用来说仅占极少数
      1. 在新生代建立全局数据结构记忆集，将老年代划分若干块，并标记哪一块内存存在跨代引用。避免了当仅收集新生代时，需要遍历老年代对象对新生代对象的可达引用

3. 标记-清除算法
   1. 先标记，再清除
   2. 执行效率不稳定；内存空间碎片化严重

4. 标记-复制算法
   1. 将分区分成相等两部分，当一部分内存用完了，将存活的对象复制到另一块，再将当前块的内存清理
   2. 简单；空间浪费了一半

5. 标记-整理算法
    1. 标记对象
    2. 让存活对象向内存空间一端移动，清理边界外的内存
    3. 移动对象花费代价

### HostSpot算法细节
1. 根节点枚举，由于对象引用不断变化，必须暂停用户进程
2. 安全点
- jvm通过OopMap找到对象引用位置，而不是检查所有执行上下文和全局引用位置。
- jvm只在特定位置（安全点）生成OopMap
  - 抢先式中断
  - 主动式中断

3. 安全区域
- 安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。
- 用户线程处于sleep状态或blocked状态，线程无法响应虚拟机的中断请求，不能到达安全点中断挂起自己  

4. 记忆集和卡表
- 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。 
- 为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集的数据结构，用以避免把整个老年代加进GC Roots扫描范围。 
- 三种精度实现方案
  - 字长精度，每个记录精确到机器字长，该字含有跨代指针
  - 对象精度，每个记录精确到一个对象，该对象里有字段含有跨代指针。
  - 卡精度，卡表。每个记录精确到一块内存区域，该区域内有对象含有跨代指针。
    - 卡页，节数组CARD_TABLE（卡表最简单形式）的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page） 
    - 当卡页内有一个对象存在跨代指针，则将卡表对于数组元素置为1，表示脏。垃圾回收时，筛选卡表中变脏的元素，将其加入GC Roots扫描。

- 卡表元素维护问题

- 伪共享问题
  - 伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。

5. 写屏障
- 解决卡表元素维护问题

6. 并发可达性分析
- 收集线程和用户线程并发时，可能出现将存活对象标记为死亡
- 解决并发扫描时对象消失问题
  - 产生条件
    - 赋值器插入了一条或多条从黑色对象（扫描结束）到白色对象的新引用
    - 赋值器删除了全部从灰色对象（正在扫描，未扫描完）到该白色对象（未扫描）的直接或间接引用
  - 增量更新，破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
  - 原始快照，破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索


### 经典垃圾收集器
1. Serial收集器，单进程收集器
2. ParNew收集器，多线程并行收集器
3. Parallel Scavenge收集器，新生代收集器，标记-复制
4. Serial Old收集器，Serial收集器老年代版本，基于标记-整理
5. Parallel Old收集器是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现
6. CMS收集器，基于标记-清除
   1. 初始标记，标记GC Roots直接关联到的对象；需要暂停其它线程
   2. 并发标记，从GC Roots直接关联到的对象搜索间接关联的对象，可以和垃圾收集线程并发运行
   3. 重新标记，修正并发标记期间，产生变动的标记对象；需要暂停其它线程
   4. 并发清除，清除死亡对象
   5. 缺点
      1. 对处理器资源敏感
      2. 无法处理浮动垃圾（并发标记和并发清理产生的垃圾对象）
      3. 空间碎片
   6. 收集线程与用户线程互不干扰：增量更新算法
   7. jdk9被舍弃
7. Garbage First收集器，整体标记-整理，局部region标记-复制
   1. 基于region内存布局，将java堆划分为多个大小相等的独立区域，每个区域都可以是新生代或老年。G1收集器追踪每个region垃圾的价值大小（价值即回收所获得的空间大小以及回收所需时间的经验值），维护一个优先级列表，优先处理回收价值最大的region。可以指定最大停顿时间。动态确定回收集。  
   2. 跨regin引用问题：通过记忆集避免GC Roots扫描。每个region维护自己的记忆集，记录其它region指向自己的指针  
   3. 收集线程与用户线程互不干扰：原始快照SATB算法。G1收集器为每个region分配两个TAMS指针，将region一部分空间划分处理并发回收时产生的新对象，其地址在两个指针以上，默认是存活的
   4. 过程
      1. 初始标记，标记GC Roots能直接关联到的对象，并且修改TAMS指针的值
      2. 并发标记，从GC Root开始对堆中对象进行可达性分析，找出要回收的对象，扫描结束后重新处理SATB记录下的在并发时有引用变动的对象
      3. 最终标记，对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
      7. 筛选回收，负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。
8. CMS、G1比较
- 都是要卡表处理跨代指针，G1更加复杂，每个region都需有一份卡表（其它region引用该region）；CMS只需要处理老年代对新生代的引用，新生代建立一份全局的卡表
- 并发对象可达性问题，G1原始快照；CMS增量更新
- 都使用写（后）屏障维护卡表，CMS同步处理写屏障；G1将G1为了实现快照搜索算法还需要写前屏障跟踪并发时指针变化情况。同时把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理。

### 低延迟垃圾收集器