# 设计模式
[链接](https://www.zhihu.com/question/308850392 "leetcode知乎主页")   

![总](图片/设计模式.jpg)

## 六大原则
### 单一原则（SRP）
1. 一个类仅有一个引起它变化的原因
### 开放封闭原则（OCP）
1. 对扩张开放，对修改关闭
2. 在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。通过接口和抽象类实现。
3. 对于频繁变化的部分抽象化
### 里氏代换原则（LSP）
1. 基类出现的地方，子类也可以出现，子类型可以替换其父类型
2. 基类复用的基石
3. 实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
### 依赖倒装原则（DIP）
1. 面向接口编程，依赖于抽象，而不依赖于具体细节
### 接口隔离原则（ISP）
1. 使用多个隔离的接口，而不是一个接口
2. 降低耦合
### 迪米特原则，最少知道原则（DP）
1. 一个实体尽量少地与其它实体发生作用，使模块更独立
### 合成复用原则
1. 尽量使用聚合方式，而不是继承
## 23种模式

### 5种创建型模式

#### 1、工厂模式
1. **简单工厂**
- 工厂承担构建所有对象的职责，调用者只需简单调用
- 违背了单一原则：一个工厂负责多个产品
- 违背了开闭原则：修改产品时，需要修改工厂
2. **工厂方法**
- 解决简单工厂的两个问题，每个产品有一个专门的工厂调用者调用专门的工厂即可
- 调用者更换工厂麻烦
#### 2、抽象工厂
1. 对工厂方法的进一步优化，提取各个工厂接口
2. 调用者替换工厂简单
3. 适合新增同类工厂，不适合新增功能
#### 工厂总结
**简单工厂**：工厂方法的特例，用来生成同一等级结构种的任意产品（不支持扩展增加产品）  
**工厂方法**：解决了工厂方法的两个问题，用来生成同一等级结构种的固定产品（支持扩展增加产品）  
**抽象工厂**：对工厂方法的优化，用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品）
#### 3、单例模式
1. 避免对对象重复创建，节约空间提升效率
2. 创建方法
- 饿汉式，类加载时，声明并实例化。private修饰构造函数保证其它类无法实例化此类；无论是否需要都会被实例化
```
public class Singleton{

    private static Singleton instance = new Singleton();

    private Singleton(){
    }

    public static Singleton getInstance(){
        return instance;
    }
}
```
- 懒汉式，类加载时，只声明不实例化。线程不安全（同时间多个线程调用，instance会被实例化多次）
```
public class Singleton{

    private static Singleton instance = null;

    private Singleton(){
    }

    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```  
- 双重检测，加锁。当多个线程调用instance时，每次都需要执行sunchronized同步化方法，影响效率，所以加两重锁。JVM的指令重排可能会导致线程不安全，需要给instance变量加 volatile关键字。
```
public class Singleton{

    private static volatile Singleton instance = null;

    private Singleton(){
    }

    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
``` 
- 静态内部类  

Java 类的加载过程包括：加载、验证、准备、解析、初始化。初始化阶段即执行类的 clinit 方法（clinit = class + initialize），包括为类的静态变量赋初始值和执行静态代码块中的内容。但不会立即加载内部类，内部类会在使用时才加载。所以当此 Singleton 类加载，SingletonHolder 并不会被立即加载，所以不会像饿汉式那样占用内存。
- Java 虚拟机规定，当访问一个类的静态字段时，如果该类尚未初始化，则立即初始化此类。当调用Singleton 的 getInstance 方法时，由于其使用了 SingletonHolder 的静态变量 instance，所以这时才会去初始化 SingletonHolder，在 SingletonHolder 中 new 出 Singleton 对象。这就实现了懒加载。
- 虚拟机在加载类的 clinit 方法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化一个类，一次也只有一个线程可以执行 clinit 方法，其他线程都需要阻塞等待，从而保证了线程安全。
```
public class Singleton{

    private Singleton(){
    }

    public static Singleton getInstance(){
        return LazyHolder.instance;
    }

    private static class LazyHolder{
        private static final Singleton instance = new Singleton();
    }
}
```
- 枚举类，加锁。当多个线程调用instance时，每次都需要执行sunchronized同步化方法，影响效率，所以加两重锁。JVM的指令重排可能会导致线程不安全，需要给instance变量加 volatile关键字。
```
public enum Singleton{
    INSTANCE;
    //自定义方法
    public void operation(){
    }
}
```
#### 4、建造者模式
1. 用于构建创建过程稳定，但配置多变的对象
2. 构建静态内部类Builder，Builder与外部类有相同的属性，通过调用Builder的构造函数构建外部类
#### 5、原型模式
1. 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象
2. Java中，Object的clone()方法属于原型模式，只深拷贝基本数据类型，对于非基本数据类型需要修改接口，对Tea实现Cloneable接口
```
public class Tea implements Cloneable{
    public boolean ice;
    public String size;
    @NonNull
    @Override
    protected Tea clone() throws CloneNotSupportedException{
        return (Tea) super.clone();
    }
}
private void order(){
    Tea a = new Tea();
    a.ice=false;
    a.size=big;
    //无效，a、b指向同一个对象
    Tea b = a;
    //有效，深拷贝，此处的clone经过修改，可以深拷贝Tea
    Tea c = a.clone();
}
```

### 7种结构型模式
#### 1、适配器模式
